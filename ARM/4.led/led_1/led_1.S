/*
 *
 *	名字：led_1.S
 *	作用：点亮所有的led灯
 *
 */
 
//ldr和str的理解：ldr是加载，加载是加载到cpu，那个地址都是内存地址来的。
//				  str是写入、储存的意思，写入是写入内存，那个地址都是内存地址来的
//第一个ldr 就是把那个地址加载到r0（cpu的）这个寄存器上来，地址就是一大串的数字寄存器就是32位的，刚刚好
//第二个ldr就是把数字0x11111111加载到r1（cpu的）这个寄存器来
//str就是寄存器间接寻址。功能是把r1中的数写入到r0中的数为地址的内存中去，[r0]就表示它是个地址
 
 _start:						//这里用的是ldr的伪命令，就是不用区分合法立即数还是非法立即数，=就是伪，%#就是真
	ldr r0, =0xE0200240			//0xE0200240对应的是GPJ0CON寄存器，它就是控制接口的状态的，是输出还是输入
	ldr r1, =0x11111111			//0x11111111就对应着8个接口的状态，1就表示输出状态，0就表示输入状态，每个接口就有
	str r1, [r0]				//8个状态，其他状态可以查数据手册就知道了
	ldr r2, =0xE02000A0			//下面这个就是第四个led灯的亮起来，地址就是0xE02000A0，查数据手册就知道在哪个端口了
	ldr r3, =0x0010				//这里只是把那个led对应的接口把它调为输出模式
	str r3, [r2]
	
	ldr r0, =0x0				//这里的0表示的就是输出了低电平，如果是1的话就输出的是高电平
	ldr r1, =0xE0200244			//0xE0200244对应的是GPJ0DAT寄存器，它就是用来输出什么的，是输出高电平还是低电平
	str r0, [r1]
	ldr r2, =0xE02000A4
	ldr r3, =0x0
	str r3, [r2]
	
flag:							//这里就是一个死循环，相当于c语言中的while(1)那样
	b flag						//b是跳转命令，就是不断的跳转到flag上
 
 
 /*
 总结：
 软件到底是怎么控制硬件的？
 软件应该就是通过控制寄存器来控制硬件的，寄存器中的0和1就表示不同的状态了
 arm中就是统一编址的模式了，寄存器的地址也就是内存的地址，改变寄存器就可以控制硬件了
 */
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 